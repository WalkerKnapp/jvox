import org.gradle.internal.jvm.Jvm

import java.nio.file.Files
import java.util.stream.Collectors

plugins {
    id 'cpp-library'
}

assemble {
    dependsOn ":jvox-core:generateJniHeaders"
    dependsOn "compileCuda"
}

library {
    binaries.configureEach {
        def compileTask = compileTask.get()
        def linkExecutable = linkTask.get()

        if(toolChain instanceof VisualCpp) {
            linkExecutable.linkerArgs.add("/DEFAULTLIB:glu32.lib")
            linkExecutable.linkerArgs.add("/DEFAULTLIB:opengl32.lib")
            linkExecutable.linkerArgs.add("/DEFAULTLIB:winmm.lib")
            linkExecutable.linkerArgs.add("/DEFAULTLIB:gdi32.lib")

            linkExecutable.linkerArgs.add("/LIBPATH:B:\\Programs\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.2\\lib\\x64")
        } else if (toolChain instanceof GccCompatibleToolChain) {
            linkExecutable.linkerArgs.add("-lgluit")
            linkExecutable.linkerArgs.add("-lwinmm")
            linkExecutable.linkerArgs.add("-lglu32")
            linkExecutable.linkerArgs.add("-lopengl32")
            linkExecutable.linkerArgs.add("-lgdi32")
        }
    }

    dependencies {
        implementation project(":jvox-trimesh-natives")
    }

    source.from {
        files(fileTree(dir: 'src/main/cpp'),
                fileTree(dir: 'libs/cuda_voxelizer/src', exclude: 'main.cpp', includes: ["**/*.cpp", "**/*.h"]),
                // Manually build with trimesh2, since transitive dependencies don't want to work.
                '../trimesh-natives/libs/trimesh2/gluit', '../trimesh-natives/libs/trimesh2/libsrc')
    }

    publicHeaders.from {
        files('src/main/headers')
    }
    privateHeaders.from {
        files('libs/cuda_voxelizer/src', 'libs/glm',
                // Manually build with trimesh2, since transitive dependencies don't want to work.
                '../trimesh-natives/libs/trimesh2/include', '../trimesh-natives/libs/trimesh2/include/GL')
    }
}

// Find CUDA
def cudaPath

if(System.getenv("CUDA_PATH") == null) {
    throw new IllegalStateException("CUDA not found: CUDA_PATH environment variable does not exist.")
}

cudaPath = file(System.getenv("CUDA_PATH")).toPath()

task compileCuda(type:Exec, group: 'build') {
    file("build/obj/main/cuda").mkdirs()

    ArrayList<String> command = new ArrayList<>();
    command.add(cudaPath.resolve('bin').resolve('nvcc.exe'))

    command.add('--compile')
    command.add('--output-directory')
    command.add(file("build/obj/main/cuda").toString())

    library.publicHeaders.forEach { file -> command.add("--include-path"); command.add(file.toString()) }
    library.privateHeaders.forEach { file -> command.add("--include-path"); command.add(file.toString()) }

    fileTree(dir: 'libs/cuda_voxelizer/src', includes: ['**/*.cu', '**.*.cuh']).forEach { file ->
        command.add(file.toString())
    }

    println "Compile Cuda Command: " + command.stream().map { obj -> obj.toString() } .collect(Collectors.joining(" "))
    commandLine command
}

System.out.println(library.source.from)

components.main.binaries.whenElementFinalized { binary ->

    project.dependencies {
        System.out.println("Including JNI Path")
        def javaIndludes = Jvm.current().javaHome.toPath().resolve("include")
        add(binary.includePathConfiguration.name, files(javaIndludes))

        for(java.nio.file.Path child : Files.newDirectoryStream(javaIndludes, { path -> Files.isDirectory(path) })) {
            add(binary.includePathConfiguration.name, files(child))
        }

        // Include CUDA
        def cudaIncludePath
        def cudaLibPath

        if(Files.exists(cudaPath.resolve("Include"))) {
            cudaIncludePath = cudaPath.resolve("Include")
        } else if(Files.exists(cudaPath.resolve("include"))) {
            cudaIncludePath = cudaPath.resolve("include")
        } else {
            throw new IllegalStateException("Could not find Cuda Include folder. Check your Cuda install and your CUDA_PATH environment variable.")
        }

        def architectureName = binary.getTargetPlatform().getTargetMachine().getArchitecture().getName()

        if(architectureName == MachineArchitecture.X86) {
            cudaLibPath = cudaPath.resolve("lib").resolve("Win32")
        } else if (architectureName == MachineArchitecture.X86_64) {
            cudaLibPath = cudaPath.resolve("lib").resolve("x64")
        } else {
            throw new GradleException("Unknown target platform: " + architectureName)
        }

        add(binary.includePathConfiguration.name, files(cudaIncludePath));
        for(java.nio.file.Path child : Files.newDirectoryStream(cudaLibPath)) {
            add(binary.linkLibraries.name, files(child))
        }

        // Link against FreeGLUT
        add(binary.linkLibraries.name, files('../trimesh-natives/libs/freeglut/lib/x64/freeglut.lib'))

        // Force link generated CUDA libraries
        fileTree(dir: 'build/obj/main/cuda').forEach { f -> add(binary.linkLibraries.name, files(f.toString())) }
    }
}